#!/usr/bin/env bash
VERSION="v2.1.2-0"

## Helper script to establish a QMUX connection. Once the connection is established
## a file named "ip-session-qmimuxX" is created with several information like:
##
##   - IP, Gateway, DNS to configure the routing
##   - HANDLE and CID to close the connection
##
## usage: tqmi-connect [options]
##
## options:
##    -d, --device <path>
##    -c, --connect
##    -r, --release
##    -a, --apn <string>
##    -i, --iface <string>  [default: wwan0]
##    -m, --muxid <number>, valid numbers 112 and 113 [default: 112]
##    -p, --ip_type <number> [default: 4]
##    -u, --mtu <number> [default: 16384]
##    -v, --verbose
##    -x, --profile
##
## Examples for USB connection:
##
##   Establish a network connection on qmimux with mux-id 112
##     $ tqmi-connect -d /dev/cdc-wdm0 --connect --apn web.omnitel.it --iface wwan0 --muxid 112
##
##   Establish a network connection creating a 3gpp profile
##     $ tqmi-connect -d /dev/cdc-wdm0 --connect --profile --apn mobile.vodafone.it --iface wwan0 --muxid 113
##
##   Release a network connection. IMPORTANT NOTE: iface is not wwanX, but qmimuX
##     $ tqmi-connect -d /dev/cdc-wdm0 --release --iface qmimux0
##
## Examples for PCIe connection:
##
##   Establish a network connection on rmnet0 with mux-id 112
##     $ tqmi-connect -d /dev/wwan0qmi0 --connect --apn web.omnitel.it --iface mhi_hwip0 --muxid 112
##
##   Release a network connection. IMPORTANT NOTE: --iface is not mhi_hwip0, but rmnetX
##     $ tqmi-connect -d /dev/wwan0qmi0 --release --iface rmnet0

info() {
    echo "[+] $@"
}

err() {
    echo "[!] $@"
}


# CLInt GENERATED_CODE: start
# Default values
_iface=wwan0
_muxid=112
_ip_type=4
_mtu=16384

# Global variable for saving the MTU for the qmimux interface
qmimux_mtu=

# No-arguments is not allowed
[ $# -eq 0 ] && sed -ne 's/^## \(.*\)/\1/p' $0 && exit 1

# Converting long-options into short ones
for arg in "$@"; do
  shift
  case "$arg" in
"--device") set -- "$@" "-d";;
"--connect") set -- "$@" "-c";;
"--release") set -- "$@" "-r";;
"--apn") set -- "$@" "-a";;
"--iface") set -- "$@" "-i";;
"--muxid") set -- "$@" "-m";;
"--ip_type") set -- "$@" "-p";;
"--mtu") set -- "$@" "-u";;
"--table") set -- "$@" "-t";;
"--verbose") set -- "$@" "-v";;
"--profile") set -- "$@" "-x";;
  *) set -- "$@" "$arg"
  esac
done

function print_illegal() {
    echo Unexpected flag in command line \"$@\"
}

# Parsing flags and arguments
while getopts 'hcrvxd:a:i:m:p:u:' OPT; do
    case $OPT in
        h) sed -ne 's/^## \(.*\)/\1/p' $0
           exit 1 ;;
        c) _connect=1 ;;
        r) _release=1 ;;
        v) _verbose=1 ;;
        x) _profile=1 ;;
        d) _device=$OPTARG ;;
        a) _apn=$OPTARG ;;
        i) _iface=$OPTARG ;;
        m) _muxid=$OPTARG ;;
        p) _ip_type=$OPTARG ;;
        u) _mtu=$OPTARG ;;
        \?) print_illegal $@ >&2;
            echo "---"
            sed -ne 's/^## \(.*\)/\1/p' $0
            exit 1
            ;;
    esac
done
# CLInt GENERATED_CODE: end

# disable PCIe quirk flag by default
_pcie=0

if [[ $EUID != 0 ]]; then
    err "run as root"
    exit 1
fi

# Check inputs
if [[ -z $_device ]]; then
    err "--device flag is mandatory"
    echo "---"
    sed -ne 's/^## \(.*\)/\1/p' $0
    exit 1
fi
if [[ ! $_muxid -gt 0 ]]; then
    err "mux-id must be > 0"
    exit 1
fi
_cid=0
_qmimux=

# Error management
STAGE_START=1   # before setting qmimux
STAGE_QMIMUX=2  # after qmimux, before start network
STAGE_START_NETWORK=3   # after start network
STAGE_END=4     # successful end
_stage=$STAGE_START
trap catch_exit EXIT
catch_exit() {
    # Script ended successfully, nothing to do
    [[ $_stage = $STAGE_END ]] && exit 0

    # Clean ups
    err "script interrupted! Cleaning up..."
    sleep 1
    [[ $_stage -ge $STAGE_START_NETWORK ]] && wds_stop_network
    [[ $_stage -ge $STAGE_QMIMUX ]] && remove_qmux $_iface $_qmimux $_muxid $_pcie
    wds_delete_profile
    # release client
    qmicli -p -d $_device --wds-noop 2>/dev/null
}

[ ! -z $_verbose ] && verbose="--verbose "

mask2cdr () {
   # Assumes there's no "255." after a non-255 byte in the mask
   local x=${1##*255.}
   set -- 0^^^128^192^224^240^248^252^254^ $(( (${#1} - ${#x})*2 )) ${x%%.*}
   x=${1%%$3*}
   echo $(( $2 + (${#x}/4) ))
}

exe() {
    # command to execute
    cmd="$1"
    # time to wait after the command has been executed.
    # The 0.5 seconds interval has been experimentally shown effective
    # to smooth the execution of the script. Only wds-start-network requires
    # a longer time of 1s.
    sleep_time=${2:-0.5}

    echo ""
    echo "    $cmd"
    output=`$cmd`
    local errcode=$?
    if [[ -n "$output" ]]; then
        echo "    $output"
    fi
    echo ""
    [[ $errcode != "0" ]] && exit 1
    [[ $sleep_time ]] && sleep $sleep_time
    return $errcode
}

fn980_quirk() {
    cmd="qmicli -p -d $_device --dms-get-model"
    set +e
    while true; do
        exe "$cmd"
        check=$(echo "$output" | grep "Device model retrieved" | wc -l)
        if [[ $check == 0 ]]; then
            echo -n "."
            sleep 1
            continue
        fi
        break
    done
    FN980_QUIRK=$(echo "$output" | grep FN980 | wc -l)
    if [[ $FN980_QUIRK == 1 ]]; then
        info "FN980 modem detected, start-network with profile ID"
        _profile=1
    fi
}

pcie_quirk() {
    if [[ $_device =~ wwan ]]; then
        info "PCIe modem detected"
        let _pcie=1
    fi
}

identify_quirks() {
    fn980_quirk
    pcie_quirk
}

add_qmux_manually() {
    # For qmicli without link-management
    local iface=$1
    local mux_id=$2
    # The qmimux label (e.g. qmimux0) is expected to be created incrementally,
    # so if there are N qmimux already (e.g. 2: qmimux0, qmimux1),
    # the new one should be qmimuxN (e.g. qmimux2)
    qmimux_count=$(cat /sys/class/net/$iface/qmi/add_mux | wc -l)
    _qmimux=qmimux$qmimux_count
    info "echo $mux_id > /sys/class/net/$iface/qmi/add_mux"
    echo $mux_id > /sys/class/net/$iface/qmi/add_mux
    if [[ $? != 0 ]]; then
        err "Could not create qmimux"
        exit 1
    fi
}

add_qmux_via_qmicli() {
    local iface=$1
    local mux_id=$2
    cmd="qmicli -p -d $_device --link-add=iface=$iface,mux-id=$mux_id"
    echo "    $cmd"
    output=`$cmd`
    echo "    $output"
    if [[ $(echo "$output" | grep successfully | wc -l) == "0" ]]; then
        err "could not add qmux"
        exit 1
    fi
    _qmimux=$(echo "$output" | grep "iface name" | cut -d":" -f2)
    _qmimux=${_qmimux:1}  # removing leading whitespace
    if [[ -z $_qmimux ]]; then
        err "could not get qmimux iface name"
        exit 1
    fi
}

add_qmux() {
    local iface=$1
    local mux_id=$2

    info "Creating qmux with id $mux_id"
    if [[ $_pcie -eq 1 ]]; then
        exe "ip link add link $_iface type rmnet mux_id $_muxid"

        # Retrieving the name of the just created rmnet.
        counter=`ip link show | grep rmnet | wc -l`
        if [[ $counter -eq 0 ]]; then
            err "could not find any rmnet interface"
            exit 1
        fi
        if [[ $counter -eq 1 ]]; then
            # expected line is
            # n: rmnet0@mhi_iphw0...
            _qmimux=`ip link show| grep rmnet0 | cut -d' ' -f2 | cut -d'@' -f1`
        fi
        if [[ $counter -eq 2 ]]; then
            # expected line is
            # n: rmnet1@mhi_iphw0...
            _qmimux=`ip link show| grep rmnet1 | cut -d' ' -f2 | cut -d'@' -f1`
        fi
    else
        curr_mux_id=$(cat /sys/class/net/$_iface/qmi/add_mux | grep $mux_id | wc -l)
        if [[ $curr_mux_id != "0" ]]; then
            # We can not get the qmimux associated with a given mux-id, so we exit
            # with an error message if the required mux-id is already in use
            err "mux-id 0x$_muxid is already in use."
            err "Please, select a different mux-id, or remove them all before trying again."
            exit 1
        fi

        has_link_add=$(qmicli --help-link-management 2>/dev/null | grep link-add | wc -l)
        if [[ $has_link_add == "0" ]]; then
            add_qmux_manually $iface $mux_id
        else
            add_qmux_via_qmicli $iface $mux_id
        fi
        if [[ -z $_qmimux ]]; then
            err "Could not create qmimux"
            exit 1
        fi
    fi

    info "created interface \"$_qmimux\""
    _stage=$STAGE_QMIMUX
}

remove_qmux_manually() {
    # Get the mux-id either from the CLI via --muxid or from the ip-session
    # configuration file.
    local iface=$1
    local mux_id=$2
    info "echo $mux_id > /sys/class/net/$iface/qmi/del_mux"
    echo $mux_id > /sys/class/net/$iface/qmi/del_mux
    if [[ $? != 0 ]]; then
        err "Could not remove qmimux"
        exit 1
    fi
}

remove_qmux_via_qmicli() {
    local qmux_iface=$1
    local mux_id=$2
    exe "qmicli -p -d $_device --link-delete=link-iface=$qmux_iface,mux-id=$mux_id"
}

remove_qmux() {
    local iface=$1
    local qmux_iface=$2
    local mux_id=$3
    local pcie=$4

    info "deleting rmnet with mux-id $mux_id"

    if [[ $pcie -eq 1 ]]; then
        exe "ip link del $qmux_iface"
    else
        has_link_delete=$(qmicli --help-link-management 2>/dev/null | grep "link-delete=" | wc -l)
        if [[ $has_link_delete == "0" ]]; then
            remove_qmux_manually $iface $mux_id
        else
            remove_qmux_via_qmicli $qmux_iface $mux_id
        fi
    fi
}

configure_iface() {
    info "Configuring parent network interface..."
    exe "ip addr flush $_iface"
    exe "ip link set $_iface down"

    info "Setting data format..."
    exe "qmicli -p -d $_device --wda-set-data-format=link-layer-protocol=raw-ip,ul-protocol=qmap,dl-protocol=qmap,dl-max-datagrams=32,dl-datagram-max-size=$_mtu"
    mtu=$(echo "$output" | sed -nr "s/Downlink data aggregation max size: '([0-9]+)'/\1/p")

    if [[ $_pcie -eq 0 ]]; then
        info "Setting MTU $mtu..."
        exe "qmicli -p -d $_device --set-expected-data-format=802-3"
        exe "ip link set $_iface mtu $mtu"
        exe "qmicli -p -d $_device --set-expected-data-format=raw-ip"
    fi
}

dms_get_software_version() {
    info "Getting software version..."
    cmd="qmicli -p -d $_device --dms-get-software-version"
    while true; do
        exe "$cmd"
        check=$(echo "$output" | grep "Software version" | wc -l)
        if [[ $check == 0 ]]; then
            echo -n "."
            sleep 1
            continue
        fi
        break
    done
}

nas_get_home_network() {
    info "Checking Network"
    cmd="qmicli -p -d $_device --nas-get-home-network"
    exe "$cmd"
    check=$(echo "$output" | grep "Successfully got home network" | wc -l)
    if [[ $check == 0 ]]; then
        err "Modem is not connected to the Home network"
        exit 1
    fi
}

nas_get_signal_strength() {
    info "Checking Signal strength"
    cmd="qmicli -p -d $_device --nas-get-signal-strength"
    exe "$cmd"

}

wds_get_client_id() {
    if [[ "$_cid" == 0 ]]; then
        cmd="qmicli $verbose -p -d $_device --wds-noop --client-no-release-cid"
        exe "$cmd"
        _cid=$(echo "$output" | sed -n "s_\s*CID: '\([0-9]*\)'_\1_p")
    fi
}

wds_bind_mux_data_port() {
    local ep_type="hsusb"
    local ep_iface_number=2
    if [[ $_pcie -eq 1 ]]; then
        ep_type="pcie"
        ep_iface_number=4
    fi

    info "Binding mux data port \"$_muxid\""
    exe "qmicli -p -d $_device --wds-bind-mux-data-port=mux-id=${_muxid},ep-iface-number=${ep_iface_number},ep-type=${ep_type} --client-no-release-cid --client-cid=$_cid"
}

wds_create_profile_id() {
    if [[ "$_ip_type" == 4 ]]; then
        _pdp_type="IP"
    else if [[ "$_ip_type" == 6 ]]; then
            _pdp_type="IPV6"
        else
            _pdp_type="IPV4V6"
        fi
    fi
    info "Creating profile"
    cmd="qmicli $verbose -p -d "$_device" --wds-create-profile=3gpp,apn=$_apn,pdp-type=$_pdp_type --client-no-release-cid --client-cid=$_cid"
    exe "$cmd"
    _profile_id=$(echo "$output" | sed -n "s_\s*Profile index: '\([0-9]*\)'_\1_p")
}

wds_start_network() {
    local sleep_seconds=1
    if [[ -z "$_profile" ]]; then
        cmd="qmicli $verbose -p -d "$_device" --wds-start-network=apn=$_apn,ip-type=$_ip_type --client-no-release-cid --client-cid=$_cid"
    else
        cmd="qmicli $verbose -p -d "$_device" --wds-start-network=3gpp-profile=$_profile_id --client-no-release-cid --client-cid=$_cid"
    fi
    exe "$cmd" "$sleep_seconds"
    check=$(echo "$output" | grep "Network started" | wc -l)
    if [[ $check == 0 ]]; then
        err "start network failed"
        exit 1
    fi
    _handle=$(echo "$output" | sed -n "s_\s*Packet data handle: '\([0-9]*\)'_\1_p")
    _stage=$STAGE_START_NETWORK
}

save_configuration_to_file() {
    info "saving IP configuration"
    cmd="qmicli $verbose -p -d $_device --wds-get-current-settings --client-no-release-cid --client-cid=$_cid"
    exe "$cmd"

    ip=$(echo "$output" | sed -n "s/IPv4 address: \([0-9\./]*\)/\1/p" $FILE | sed -n "s/\s*//p")
    gw=$(echo "$output" | sed -n "s/IPv4 gateway address: \([0-9\.]*\)/\1/p" $FILE | sed -n "s/\s*//p")
    netmask=$(echo "$output" | sed -n "s/IPv4 subnet mask: \([0-9\.]*\)/\1/p" $FILE | sed -n "s/\s*//p")
    network=$(mask2cdr $netmask)

    dns1=$(echo "$output" | sed -n "s/IPv4 primary DNS: \([0-9\./]*\)/\1/p" $FILE | sed -n "s/\s*//p")
    dns2=$(echo "$output" | sed -n "s/IPv4 secondary DNS: \([0-9\./]*\)/\1/p" $FILE | sed -n "s/\s*//p")
    qmimux_mtu=$(echo "$output" | sed -nr "s/\s*MTU: ([0-9]+)/\1/p")

    OUT=ip-session-$_qmimux
    [[ -f "$OUT" ]] && rm "$OUT"

    echo "HANDLE=$_handle"      >> $OUT
    echo "CID=$_cid"            >> $OUT
    echo "PROFILE=$_profile_id" >> $OUT
    echo "IFACE=$_iface"        >> $OUT
    echo "QMUX_IFACE=$_qmimux"  >> $OUT
    echo "MUX_ID=$_muxid"       >> $OUT
    echo "PCIe=$_pcie"          >> $OUT
    echo "IP=$ip"               >> $OUT
    echo "GW=$gw"               >> $OUT
    echo "NETMASK=$netmask"     >> $OUT
    echo "DNS1=$dns1"           >> $OUT
    echo "DNS2=$dns2"           >> $OUT
    echo "MTU=$qmimux_mtu"      >> "$OUT"
    echo "CDR=$network"         >> $OUT
    info "ip configuration saved in $OUT"
}

set_mtu() {
    info "Settting MTU"
    mtu=$1
    cmd="ip link set $_qmimux mtu $mtu"
    exe "$cmd"
}

wds_delete_profile() {
    local profile_id=${PROFILE:-$_profile_id}
    if [[ -z $profile_id ]]; then
        # No profile id found, nothing to do
        return
    fi
    info "deleting profile $profile_id"
    cmd="qmicli $verbose -p -d "$_device" --wds-delete-profile=3gpp,$profile_id"
    exe "$cmd"
    # unset profile_id to prevent future attempts to print this message again.
    _profile_id=
}

check_connection_status() {
    cmd="qmicli -p -d $_device --wds-get-packet-service-status --client-no-release-cid --client-cid=$_cid"
    echo $cmd
    output=$($cmd)
    if [[ $? != 0 ]]; then
        exit 1
    fi
    echo "$output" | grep "Connection status:"
}

set_network_address() {
    # Network interface needs to be set up after start-network
    info "Setting network address"
    exe "ip addr add $ip/$network dev $_qmimux"

    info "Setting $_iface up"
    exe "ip link set $_iface up"
}

wds_stop_network() {
    local cid=${CID:-$_cid}
    local handle=${HANDLE:-$_handle}
    info "Stop network"
    cmd="qmicli -p -d $_device --wds-stop-network=$handle --client-cid=$cid"
    echo "    $cmd"
    output=`$cmd 2>&1`
    echo "   $output"
}

release() {
    configuration="ip-session-$_iface"
    if [[ ! -f  $configuration ]]; then
        err "could not find configuration file $configuration"
        err "Check if the --iface flag is configured correctly (e.g. qmimux0/rmnet0, not wwan0)"
        exit 1
    fi
    source $configuration

    wds_stop_network
    info "set $IFACE down"
    exe "ip link set $IFACE down"
    remove_qmux $IFACE $QMUX_IFACE $MUX_ID $PCIe
    wds_delete_profile
    info "Deleting '$configuration' configuration file."
    exe "rm $configuration"
}


### MAIN ###
info "tqmi-connect:" $VERSION
info "$(qmicli --version | grep 'qmicli')"

if [[ -z $_release ]] && [[ -z $_connect ]]; then
    err "No command given! Either use --connect or --release"
fi

if [[ ! -z $_release ]]; then
    release
fi

if [[ ! -z $_connect ]]; then
    identify_quirks
    dms_get_software_version
    configure_iface
    add_qmux $_iface $_muxid
    nas_get_home_network
    nas_get_signal_strength
    wds_get_client_id
    wds_bind_mux_data_port
    [[ ! -z $_profile ]] && wds_create_profile_id
    wds_start_network
    check_connection_status
    save_configuration_to_file
    set_mtu "$qmimux_mtu"
    set_network_address

    info "################################################################"
    info "$_qmimux interface configured. The network is currently DOWN"

    info "Before configuring the routing for $_qmimux, remember to"
    info "bring it up (e.g. ip link set $_qmimux up)"
    info "################################################################"
fi

_stage=$STAGE_END
